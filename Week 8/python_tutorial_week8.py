# -*- coding: utf-8 -*-
"""
Created on Sat Oct  1 15:19:59 2016

File previously named cycle0_week6_MLw4.py

@author: jledue
"""

# Remember our convienent shorthand before :)
import numpy as np
import matplotlib.pyplot as plt

"""
So far we have spent most of our time learning about various data strucutures
(arrays, lists) and how to manipulate them with indexing.  For example, 
we will use arrays to represent our data (think time course -> 1d array,
image -> 2d array) and indexing to isolate and work 
with specific elements (think time points, pixels, for example).

However, our data is usually stored in files which means in order to read 
it in to python we must be able to generate and manipulate text variables to 
represent the file names.  Such text variables are called strings.

We just worked with glob.glob in the SWC Lesson which gives us the names of
files matching a pattern.  This is a very convienent way to get lists of files
that will then be read in, ie with np.loadtxt in the example.

Here we will get a bit more practice manipulating strings by indexing and 
concantenation and generate some filenames in combination with a loop.    
"""


# first let's look at a string.  Evaluate:

a='a string'

# Note that single and double quotes are both valid to denote strings in python
# For example:

a="a string"

"""
A string is a group of characters surrounded by quotes.  

In this case we use the = to assign the characters to a variable called a.
a can be indexed like arrays.  You can think of a string variable
as an array with a single row.  Each element is a single charactor rather
than a number.
"""

# So variable a can be indexed, for example evaluate:

a[0]
a[2:]

# 1. Which characters will this command return?

a[0::2]

# You can use the built-in function print to display strings as well
# the command window.

#For example:

print(a)

"""
Write print statements to print the first 4 charactes in a and another to
print the last 3 characters.

"""



"""
% So as you can see, by indexing you can isolate part of the string, which is
% useful if you only want to look at or use part of it.

% This can handy for filenames.  Let's work with the 4 text files:
% VicPos1_Roi1.txt, VicPos1_Roi2.txt, VicPos1_Roi3.txt, & VicPos1_Roi4.txt.

% For example, say your input filename was stored in the variable
% myfile_in.  Evaluate:
"""

myfile_in='VicPos1_Roi1.txt'

"""
% Imagine that you've loaded your data, done some analysis and now want to 
% save the results in a .npy file.

% We can use this filename as a basis for the output name to keep things organized:

% Index the string to isolate the filename from the .txt extension:
"""



# Note that the 4 characters at the the end are the extension .txt so we
# can leave them off by keeping only the charaters from the first to the fourth
# from the end.

#This can also be done using the string split method.  Try it:


#Print out the result to confirm:
print(myfile_out)

"""
Next we can concatenate some meaningful text to describe the results
(_RESULTS in this case) along with the appropriate extension .npy.
Concatenation is accomplished with the + operator.
"""



# and now we have a filename to store our results in

print(myfile_out)

# Our 4 text files are named in a numerical sequence.  We can use these
# string manipulations to automatically generate these file names.

# store the first part of the filename in a variable, ie the text up to the number:
file_prefix=

#store the last part (without the numerical bit) in another variable, ie the extension:
file_suffix=

# We can also generate filenames referring to any numbered ROI by
# concatenation.  To do this we need to make use of the built in  function 
# called str.  This converts a number, 4 for example, to a string '4'
# so that we can concatenate it with other strings with the + as above.



# or the 3rd...



"""
This is a good time to re-visit loops as we can make use of them to generate
our file names.  For loops allow you to repeat a set of commands a given 
number of times.  They always begin with for.  After the for, you define a 
special variable known as the loop
variable and define a set of values.  Often this is an ordered list
of numbers in our example (1,2,3,4) (generated by the range command).
The first time the loop runs the variable i will be set to its first
value, eg 1, and the second time 2 and so on up to 4 in our example.  Try
this loop below.  
"""

# Example Loop 1:
for i in range(1,5):
    print(i) 

"""
It runs the print command 4 times.  Once for each value of the loop
variable i.  You should see it printed in the console.  Note that the commands 
repeated by the loop are indented with respect to the for.

So, by combining the loop with our filename by concantenation,
we can use it to make filenames
"""

# Example loop 2:
for i in range(1,5):
    the_name=file_prefix+str(i)+file_suffix
    print(the_name)
    
""" 
You can imagine generating each filename in turn in your loop and
using the name to read its data into a variable.

So once you have the name of a file in a string how do you read it in??

It depends on the type of data.
"""

# for text files use the numpy loadtxt command:

dat=np.loadtxt(a_file)

#Remeber that you might need to cd (change directory) to the folder containing
#the files or supply the full path

# You can see dat is assigned the numbers that are in the filename stored
# in a_file
dat[:,0]=dat[:,0]/5.92;#Hz
plt.figure;
plt.plot(dat[:,0],dat[:,1])

"""
2. Combine the loop above and the load command to read in each txt file
for ROI's 1-4 in sequence.

Let's break this down into a few steps.

2.1 Before we start let's think about the array we need to store the data in 
all the files:
How many dimensions should it have?  How many values of the index for
each dimension?
"""  

"""
2.2 We have already read in one of our txt files above and
seen with the figure that it is a timecourse of a signal. ie it is two columns
of numbers. This data is stored in array dat and we can see in the 
variable explorer that it is 115x2.  We could use these values directly when 
setting up our matrix to hold everything, but let's use numpy functions 
to do this automatically. Use the shape command find the shape of dat.  
Store the result in s.
"""



"""
2.2 We know that we have 4 files to read in.  Let's create a variable
called n_files and assign it the value 4 using the =
"""



"""
2.3 Using n_files and the values stored in s as input, use the zeros
command to set up an empty array to hold the data.  Call the matrix
all_dat.

Hint: Thinking back to 2.1, we need a matrix which has space for 4 files 
worth of 115 rows x 2 columns.
"""



"""
2.4 Refering to example loop 1 above, set up the basic template of a for loop.
"""



""" 
2.5 Inside the loop we need to do two things.  One: create and display the
filename.  This is analogous to example loop 2 above.  Put these commands
inside your loop in 2.4 or 2.5.
"""



"""
2.6 The second thing our loop needs to do is read in the data and store
it in the appropriate place in all_dat.  reading in is analogous to the
example text load above.  Put this command inside your loop, but make
sure the string variable name for your filename from 2.5  matches the
load command.  Finally index all_dat using the loop variable to store the
data from the file.
"""



# Bonus:  Check that each timecourse was successfully loaded by plotting



"""
% Ok, now an examples of how to read in an image:

We need a new import called PIL, hopefully you have it?
"""
import PIL

myimage=PIL.Image.open('sample_image.jpg')

myimage=np.array(myimage)
plt.figure();
plt.imshow(myimage)
"""
But what about paths?  You might ask...  We can't always have the files 
in the same folder as the code...

A simple approach:
you can type it in and assign it to a variable:
"""

mypath = '~/Desktop/python-novice-inflammation-data/'

# and then simply concatenate like we've been doing

fullfileandpath=mypath+myfile_in
print(fullfileandpath)

# this will look a bit different on windows, due to the c: and \
